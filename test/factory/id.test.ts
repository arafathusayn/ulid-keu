import { describe, it, expect } from "bun:test";

import { IdFactory, EncodableId } from "../../src/factory/id";
import { BaseId } from "../../src/id/base";
import { BaseCoder } from "../../src/coder/base";

class MockCoder extends BaseCoder {
  private _prefix: string;

  constructor(prefix: string) {
    super({
      valid_encoding_pattern: new RegExp(`^${prefix} `),
    });
    this._prefix = prefix;
  }

  encodeTrusted(bytes: Uint8Array): string {
    return `${this._prefix} ${String(bytes)}`;
  }

  encode(bytes: Uint8Array): string {
    return `${this._prefix} ${String(bytes)}`;
  }

  decodeTrusted(str: string): Uint8Array {
    const stripped = str.replace(new RegExp(`^${this._prefix} `), "");
    return Uint8Array.from(
      stripped.split(",").map((s) => Number(s) || 0),
    );
  }

  decode(str: string): Uint8Array {
    if (this.isValidEncoding(str)) {
      return this.decodeTrusted(str);
    }
    return this.decodeTrusted(str);
  }
}

class MockId extends BaseId {
  static generate(): MockId {
    return new this(new Uint8Array([Date.now() & 0xff]));
  }
  static MIN(): MockId {
    return new this(new Uint8Array([0]));
  }
  static MAX(): MockId {
    return new this(new Uint8Array([0xff]));
  }
}

const canonicalCoder = new MockCoder("canonical");
const rawCoder = new MockCoder("raw");

const factory = new IdFactory<MockId>({
  id: MockId,
  canonical_coder: canonicalCoder,
  raw_coder: rawCoder,
});

function assertInjectsInstanceMethod(
  injected_method: keyof EncodableId,
  generator: () => EncodableId,
) {
  describe(injected_method, () => {
    it("is injected into the instance", () => {
      const id = generator();
      const method = id[injected_method];
      if (typeof method === "function") {
        expect(() => method.call(id)).not.toThrow();
      }
    });

    it("is only injected into the instance", () => {
      generator();
      const plainId = new MockId(new Uint8Array(0));
      expect(injected_method in plainId).toBe(false);
    });
  });
}

function assertGenerator(method: "generate" | "MIN" | "MAX") {
  describe(`#${method}`, () => {
    const subject = () => factory[method]();

    it("returns an id", () => {
      expect(subject()).toBeInstanceOf(MockId);
    });

    it("always returns a different object", () => {
      expect(subject()).not.toBe(subject());
    });

    assertInjectsInstanceMethod("toCanonical", subject);
    assertInjectsInstanceMethod("toRaw", subject);
  });
}

function assertDecoder(
  method: "fromCanonical" | "fromCanonicalTrusted" | "fromRaw" | "fromRawTrusted",
  encoding: string,
) {
  describe(`#${method}`, () => {
    const subject = () => factory[method](encoding);

    it("returns an id", () => {
      expect(subject()).toBeInstanceOf(MockId);
    });

    assertInjectsInstanceMethod("toCanonical", subject);
    assertInjectsInstanceMethod("toRaw", subject);
  });
}

function assertEncoder(
  method: "toCanonical" | "toRaw",
  pattern: RegExp,
) {
  describe(`#${method}`, () => {
    const subject = () => factory[method](factory.generate());

    it("encodes the bytes of the id", () => {
      expect(subject()).toMatch(pattern);
    });
  });
}

function assertVerifier(
  method: "isCanonical" | "isRaw",
  validEncoding: string,
) {
  const conditions: Array<[string, string]> = [
    ["canonical", factory.generate().toCanonical()],
    ["raw", factory.generate().toRaw()],
    ["other", "some random string"],
  ];

  describe(`#${method}`, () => {
    const subject = (str: string) => factory[method](str);

    const trueConditions: Array<[string, string]> = [];
    const falseConditions: Array<[string, string]> = [];

    for (const condition of conditions) {
      const [name] = condition;
      if (validEncoding === name) {
        trueConditions.push(condition);
      } else {
        falseConditions.push(condition);
      }
    }

    it("detects valid encodings", () => {
      for (const [_name, encoding] of trueConditions) {
        expect(subject(encoding)).toBe(true);
      }
    });

    it("rejects invalid encodings", () => {
      for (const [_name, encoding] of falseConditions) {
        expect(subject(encoding)).toBe(false);
      }
    });
  });
}

describe(IdFactory.name, () => {
  describe("#construct", () => {
    const subject = () =>
      factory.construct(new Uint8Array([1, 2, 3]));

    it("returns an id", () => {
      expect(subject()).toBeInstanceOf(MockId);
    });

    it("directly stores the bytes", () => {
      expect(subject().bytes).toEqual(new Uint8Array([1, 2, 3]));
    });
  });

  describe("#name", () => {
    it("returns the name of the id generated by the factory", () => {
      expect(factory.name).toBe(MockId.name);
    });
  });

  describe("#type", () => {
    it("returns the class of the id generated by the factory", () => {
      expect(factory.type).toBe(MockId);
    });

    it("provides support for the instanceof operator", () => {
      expect(factory.generate()).toBeInstanceOf(factory.type);
    });
  });

  assertGenerator("generate");
  assertGenerator("MIN");
  assertGenerator("MAX");

  assertDecoder("fromCanonical", "canonical test");
  assertDecoder("fromCanonicalTrusted", "canonical test");
  assertDecoder("fromRaw", "raw test");
  assertDecoder("fromRawTrusted", "raw test");

  assertEncoder("toCanonical", /^canonical /);
  assertEncoder("toRaw", /^raw /);

  assertVerifier("isCanonical", "canonical");
  assertVerifier("isRaw", "raw");
});
